// //Мы можем использовать любую из переменных для доступа к ящику и изменения его содержимого:
//
//     let user = { name: 'Иван' };
//
// let admin = user;
//
// admin.name = 'Петя'; // изменено по ссылке из переменной "admin"
//
// alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"
// //Приведённый выше пример демонстрирует, что объект только один. Как если бы у нас был один ящик с двумя ключами и мы использовали один из них (admin), чтобы войти в него и что-то изменить, а затем, открыв ящик другим ключом (user), мы бы увидели эти изменения.

// Сравнение по ссылке
// Операторы равенства == и строгого равенства === для объектов работают одинаково.
//
//     Два объекта равны только в том случае, если это один и тот же объект.
//
//     В примере ниже две переменные ссылаются на один и тот же объект, поэтому они равны друг другу:

//     let a = {};
// let b = a;
// let c = b ;// копирование по ссылке
//
// alert( a == b ); // true, т.к. обе переменные ссылаются на один и тот же объект
// alert( a === b ); // true
// alert ( a == c); // true

//  В другом примере два разных объекта не равны, хотя оба пусты:

//     let a = {};
// let b = {}; // два независимых объекта
//
// alert( a == b ); // false
//Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы. Мы скоро изучим, как работают такие преобразования объектов, но, по правде говоря, сравнения такого рода необходимы очень редко и обычно являются результатом ошибки программиста.



//
// let user = {
//     name: "Иван",
//     age: 30
// };
//
// let clone = {}; // новый пустой объект
//
// // скопируем все свойства user в него
// for (let key in user) {
//     clone[key] = user[key];
// }
//
// // теперь в переменной clone находится абсолютно независимый клон объекта
// clone.name = "Пётр"; // изменим в нём данные
//
// alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.
// alert( clone.name ); //
//
//
// Кроме того, для этих целей мы можем использовать метод Object.assign.
//
//     Синтаксис:


// Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:
//
//     let user = { name: "Иван" };
//
// Object.assign(user, { name: "Пётр" });
//
// alert(user.name); // теперь user = { name: "Пётр" }
// Мы также можем использовать Object.assign для замены for..in на простое клонирование:
//
//     let user = {
//         name: "Иван",
//         age: 30
//     };
//
// let clone = Object.assign({}, user);
// Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.
//
// Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
//     Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
//     Возвращает объект dest.
//     Например, объединим несколько объектов в один:
//
//     let user = { name: "Иван" };
//
// let permissions1 = { canView: true };
// let permissions2 = { canEdit: true };
//
// // копируем все свойства из permissions1 и permissions2 в user
// Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }


// Вложенное клонирование
// До сих пор мы предполагали, что все свойства объекта user хранят примитивные значения. Но свойства могут быть ссылками на другие объекты. Что с ними делать?
//
//     Например, есть объект:
//
//     let user = {
//         name: "Иван",
//         sizes: {
//             height: 182,
//             width: 50
//         }
//     };
//
// alert( user.sizes.height ); // 182
// Теперь при клонировании недостаточно просто скопировать clone.sizes = user.sizes, поскольку user.sizes – это объект, он будет скопирован по ссылке. А значит объекты clone и user в своих свойствах sizes будут ссылаться на один и тот же объект:
//
//     let user = {
//         name: "Иван",
//         sizes: {
//             height: 182,
//             width: 50
//         }
//     };
//
// let clone = Object.assign({}, user);
//
// alert( user.sizes === clone.sizes ); // true, один и тот же объект
//
// // user и clone обращаются к одному sizes
// user.sizes.width++;       // меняем свойство в одном объекте
// alert(clone.sizes.width); // 51, видим результат в другом объекте
// Чтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли значение user[key] объектом, и если это так – скопировать и его структуру тоже. Это называется «глубокое клонирование».
